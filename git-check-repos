#!/bin/sh

set -eu

usage () {
    echo "usage: git check-repos [-f|-h] [<path>]"
}

list_git_repo_paths () {
    find "$1" -type d -name '.git' | xargs -I{} dirname "{}"
}

get_status_upstream_branch () {
    # Check if local branch has a upstream branch
    if git -C "$1" rev-parse @{u} 2>/dev/null >&2
    then
        if [ "$(git -C "$1" rev-parse HEAD)" = "$(git -C "$1" rev-parse @{u})" ]
        then
            # Local branch is up-to-date
            echo 'U'
        else
            # Local branch and upstream branch differ
            echo 'D'
        fi
    else
        # No upstream branch set
        echo 'N'
    fi
}

main () {
    local do_fetch=0

    while getopts ':fh' o
    do
        case "$o" in
            f)
                do_fetch=1
                ;;
            h)
                usage
                exit 0
                ;;
            *)
                usage
                exit 0
                ;;
        esac
    done

    shift "$((OPTIND-1))"

    while read repo_path
    do
        # Check if $repo_path points to a valid Git repo and it is not
        # configured to be skipped
        if ! git -C "$repo_path" rev-parse --git-dir 2>/dev/null >&2 ||
           [ "$(git -C "$repo_path" config \
                    --local --type bool --get checkrepos.skip)" = 'true' ]
        then
            continue
        fi

        if [ "$do_fetch" -eq 1 ]
        then
            # Allow fetch to fail, maybe the remote is not accessible
            git -C "$repo_path" fetch || true
        fi

        echo "$(get_status_upstream_branch "$repo_path")" "$repo_path"
    done < <(list_git_repo_paths "${1:-"$HOME"}")
}

main "$@"
