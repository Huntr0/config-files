#!/bin/sh

set -eu

STATUS_BRANCH_DIFFERS='d'
STATUS_BRANCH_NOT_SET='n'
STATUS_BRANCH_UPDATED='u'

STATUS_WORKTREE_CLEAN=' '
STATUS_WORKTREE_CHANGES='w'

usage () {
    echo "usage: git check-repos [(-a|-A)|-f|-h|-v] [<path>]"
}

error () {
    echo "error: $1" >&2
    exit 1
}

to_upper () {
    echo "$1" | tr '[a-z]' '[A-Z]'
}

list_git_repo_paths () {
    find -L "$1" -type d -name '.git' | xargs -I{} dirname "{}"
}

get_status_upstream_branch () {
    # Check if local branch has a upstream branch
    if git -C "$1" rev-parse @{u} 2>/dev/null >&2
    then
        if [ "$(git -C "$1" rev-parse HEAD)" = "$(git -C "$1" rev-parse @{u})" ]
        then
            # Local branch is up-to-date
            echo "$STATUS_BRANCH_UPDATED"
        else
            # Local branch and upstream branch differ
            echo "$STATUS_BRANCH_DIFFERS"
        fi
    else
        # No upstream branch set
        echo "$STATUS_BRANCH_NOT_SET"
    fi
}

get_status_worktree () {
    if [ -z "$(git -C "$1" status --porcelain)" ]
    then
        # Everything is committed
        echo "$STATUS_WORKTREE_CLEAN"
    else
        # Something is in the working tree
        echo "$STATUS_WORKTREE_CHANGES"
    fi
}

main () {
    local do_fetch=0
    local show_all=0
    local show_all_and_skipped=0
    local verbose=0

    while getopts ':aAfhv' o
    do
        case "$o" in
            a)
                show_all=1
                ;;
            A)
                show_all_and_skipped=1
                ;;
            f)
                do_fetch=1
                ;;
            h)
                usage
                exit 0
                ;;
            v)
                verbose=1
                ;;
            *)
                usage
                exit 0
                ;;
        esac
    done

    shift "$((OPTIND-1))"

    if [ "$show_all" -eq 1 ] && [ "$show_all_and_skipped" -eq  1 ]
    then
        error '-a and -A are mutually exclusive'
    fi

    local skip_repo='false'

    while read repo_path
    do
        # Check if $repo_path points to a valid Git repo
        if ! git -C "$repo_path" rev-parse --git-dir 2>/dev/null >&2
        then
            continue
        else
            skip_repo="$(git -C "$repo_path" config \
                            --local --type bool --get checkrepos.skip || true)"

            # Check if it is configured to be skipped (except if "-A" is
            # provided)
            if [ "$skip_repo" = 'true' ] && [ "$show_all_and_skipped" -eq 0 ]
            then
                continue
            fi
        fi

        if [ "$do_fetch" -eq 1 ]
        then
            # Allow fetch to fail, maybe the remote is not accessible
            git -C "$repo_path" fetch --quiet || true
        fi

        local status_upstream_branch="$(get_status_upstream_branch "$repo_path")"
        local status_worktree="$(get_status_worktree "$repo_path")"

        if [ "$status_upstream_branch" = "$STATUS_BRANCH_UPDATED" ] &&
           [ "$status_worktree" = "$STATUS_WORKTREE_CLEAN" ] &&
           [ "$show_all" -eq 0 ] &&
           [ "$show_all_and_skipped" -eq 0 ]
        then
            continue
        fi

        local branch_name=''

        if [ "$skip_repo" = 'true' ]
        then
            status_upstream_branch="$(to_upper "$status_upstream_branch")"
            status_worktree="$(to_upper "$status_worktree")"
        fi

        if [ "$verbose" -eq 1 ]
        then
            branch_name="[$(git -C "$repo_path" branch --show-current)]"
        fi

        echo "$status_upstream_branch$status_worktree $repo_path $branch_name"
    done < <(list_git_repo_paths "${1:-"$HOME"}") | sort
}

main "$@"
